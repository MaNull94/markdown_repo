[[Notes/Архитектура/АРХИТЕКТУРА]]

![[ознакомиться с паттернами]]

Итак, паттерны. Что это? Кодеры раз за разом делали похожие вещи и как то решили - а что бы не привести похожие идеи к общему знаменателю и не дать им названия?
На первый взгляд всё звучит отлично, но как и везде, где есть правила, ограничения, стандарты, принципы и т.п. должно быть место для здравого смысла. Т.е. не всегда и не везде стоит использовать паттерны. Хотя точнее сказать стоит их использовать там, где это будет полезно. Вода водянистая пока что :D надо проверять как на деле.

Паттерны можно разделить на категории:
1. Порождающие
	Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
2. Структурные
	Отвечают за построение удобных в поддержке иерархий классов.
3. Поведенческие
	Решают задачи эффективного и безопасного взаимодействия между объектами программы.

# Таблица паттернов, которые я хочу изучить
|Название|Тип|Краткое описание|Основной плюс|Основной минус|
|-|-|-|-|-|
|синглтон|порождающий|Создание единственного экземпляра класса, скрывая конструктор по умолчанию|Повышение стабильности работы, так как подменить экземпляр не получится|Проблемно тестировать, использовать в многопоточности|
|фабричный метод|порождающий|Изменение создания экземпляров, опираясь на интерфейс класса, вместо конкретной реализаци|Обеспечение OCP(SOLID)|Параллельные иерархии классов. А значит уменьшение скорости билда и увеличение размера проекта|
|абстрактная фабрика|порождающий|Механизм создания набора элементов, также опираясь на интерфейс, а не на класс|Обеспечение OCP|Реализуя интерфейс ты обязан реализовать его полностью. То есть создавать ВЕСЬ набор|
|билдер|порождающий|Пошаговое создание экземпляра сложного класса|Формирование абстракции создания экземпляра. Декомпозиция логики: создания и основной|Т.к. билдер содержит те же поля что и основной класс, то он жестко связан с этим классом|
|прокси|структурный|Класс, который можно подложить вместо основного класса, для добавления сервисного(обслуживающего) кода|Декомпозиция. Плюс к тому же прокси можно применить к классу, находящемуся внутри библиотеки.|Так как прокси нужен для добавления "оберточного кода" вокруг основного, этот самый код снизит общую скорость работы метода. Ведь клиент не в курсе что вызывает обертку, вместо основного класса|
|фасад|структурный|Сокрытие в чистом виде - вместо запуска 5-20 методов, ты можешь вызвать 1|Сокрытие и абстракция сложных частей системы|Вероятность появления god-object в системе|
|декоратор|структурный|
|адаптер|структурный|

# Слишком хорошо - тоже не хорошо
Иногда можно упороться и обмазаться паттернами и абстракциями с ног до головы. Пример - довольно простая задача которую обложили фабриками и прочим
[тык](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)


# Паттерны
## Порождающие
### Синглтон
[тык](https://refactoring.guru/design-patterns/singleton/java/example#example-0)
Синглтон или одиночка - паттерн позволяющий изменить механизм создания экземпляра класса, скрывая конструктор и добавляя статический метод. В методе проводится проверка, есть ли экземпляр. Если есть, то просто возвращается ссылка, если нет, создается экземпляр. Таким образом можно быть уверенным, что будет создан только один экземпляр класса.
P.S. В Spring(java) создание bean по умолчанию происходит через синглтон

Но есть те кто хейтят этот паттерн, якобы он нарушает SRP, позволяет спрятать говнокод и тому подобное. И что лучше использовать фабрику, билдер или вообще декоратор...


### Фабричный метод
[источник](https://refactoring.guru/ru/design-patterns/factory-method)
Отделяет логику создания экземпляров в отдельный метод.
Используя базовый абстрактный класс, создаётся метод:
- абстрактный, т.е. каждый наследник должен самостоятельно реализовать создание экземпляра.
- базовый класс содержит реализацию по умолчанию и наследник при необходимости может переопределить создание экземпляра
![[Pasted image 20230124132937.png]]

#### Преимущества и недостатки
Преимущества
-    Избавляет класс от привязки к конкретным классам продуктов.
-    Выделяет код производства продуктов в одно место, упрощая поддержку кода.
-    Упрощает добавление новых продуктов в программу.
-    Реализует _принцип открытости/закрытости_.

Недостатки
Может привести к созданию больших [параллельных иерархий классов](https://refactoring.guru/ru/smells/parallel-inheritance-hierarchies), так как для каждого класса продукта надо создать свой подкласс создателя.

### Абстрактная фабрика
[источник](https://refactoring.guru/ru/design-patterns/abstract-factory)
Паттерн позволяет добавлять в клиентский класс фабрику, производящую набор элементов. Так как каждый класс должен иметь высокую связность, то любой из элементов в создаваемом наборе будет иметь общую характеристику. Например
Класс `Client` содержит в себе экземпляр, ограниченный типом(интерфейсом, в случае Java/C#) `FurnitureFactory`
Есть 2 реализации `FurnitureFactory`:
- `RedFurnitureFactory`
- `YellowFurnitureFactory`
Обе эти фабрики могу производить столы, стулья и шкафы (набор)
Но у одной они будут желтого цвета, а у другой красного (характеристика)
![[Pasted image 20230125151201.png]]

#### Преимущества и недостатки
- Гарантирует сочетаемость создаваемых продуктов.
- Избавляет клиентский код от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует _принцип открытости/закрытости_.

Недостатки
-   Усложняет код программы из-за введения множества дополнительных классов.
-    Требует наличия всех типов продуктов в каждой вариации.


### Билдер
Билдер через внутренний статик класс - более компактное решение
https://www.digitalocean.com/community/tutorials/builder-design-pattern-in-java
![[Pasted image 20230125120448.png]]

[Источник](https://refactoring.guru/ru/design-patterns/builder)
**Строитель** — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

Иногда применяют дополнительный класс Директор или Распорядитель, если есть несколько схем создания экземпляра (метод make)
![[Pasted image 20230124161816.png]]

#### Преимущества и недостатки
-    Позволяет создавать продукты пошагово.
-    Позволяет использовать один и тот же код для создания различных продуктов.
-    Изолирует сложный код сборки продукта от его основной бизнес-логики.

Недостатки
-   Усложняет код программы из-за введения дополнительных классов.
-    Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.


## Структурные
### Прокси
[источник](https://refactoring.guru/ru/design-patterns/proxy)
Паттерн, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то _до_ или _после_ передачи вызова оригиналу.
![[Pasted image 20230125161042.png]]

1.  **Интерфейс сервиса** определяет общий интерфейс для сервиса и заместителя. Благодаря этому, объект заместителя можно использовать там, где ожидается объект сервиса.
2.  **Сервис** содержит полезную бизнес-логику.
3.  **Прокси** хранит ссылку на объект сервиса. После того как заместитель заканчивает свою работу (например, инициализацию, логирование, защиту или другое), он передаёт вызовы вложенному сервису. Заместитель может сам отвечать за создание и удаление объекта сервиса.
4.  **Клиент** работает с объектами через интерфейс сервиса. Благодаря этому, его можно «одурачить», подменив объект сервиса объектом заместителя.
#### Преимущества и недостатки
-    Позволяет контролировать сервисный объект незаметно для клиента.
-    Может работать, даже если сервисный объект ещё не создан.
-    Может контролировать жизненный цикл служебного объекта.
Недостатки
-   Усложняет код программы из-за введения дополнительных классов.
-    Увеличивает время отклика от сервиса.


### Фасад
[Источник](https://refactoring.guru/ru/design-patterns/facade)
Паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
![[Pasted image 20230125145626.png]]
В данном случае вместо вызова кучи методов зависимостей мы вызываем только 2:
engineStart и engineStop

1.  **Фасад** предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие данные для этого нужны.
2.  **Дополнительный фасад** можно ввести, чтобы не «захламлять» единственный фасад разнородной функциональностью. Он может использоваться как клиентом, так и другими фасадами.
3.  **Сложная подсистема** состоит из множества разнообразных классов. Для того, чтобы заставить их что-то делать, нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее. Классы подсистемы не знают о существовании фасада и работают друг с другом напрямую.
4.  **Клиент** использует фасад вместо прямой работы с объектами сложной подсистемы.
#### Преимущества и недостатки
-    Изолирует клиентов от компонентов сложной подсистемы.
Недостатки
- Фасад рискует стать [божественным объектом](https://refactoring.guru/ru/antipatterns/god-object), привязанным ко всем классам программы.


### Декоратор
### Адаптер

# Вопросы
[[notes/qq/АРХИТЕКТУРНЫЕ ПАТТЕРНЫ/почему синглтон нарушает SRP]]